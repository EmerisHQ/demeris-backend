// Code generated by sqlc. DO NOT EDIT.
// source: schema.sql

package cnsdb

import (
	"context"

	"github.com/allinbits/demeris-backend/models"
)

const addChain = `-- name: AddChain :exec
INSERT INTO chains
(
    chain_name,
    enabled,
    logo,
    display_name,
    valid_block_thresh,
    primary_channel,
    denoms,
    demeris_addresses,
    genesis_hash,
    node_info,
    derivation_path,
    block_explorer
)
VALUES
(
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12
)
ON CONFLICT
    (chain_name)
    DO UPDATE SET
        chain_name=EXCLUDED.chain_name,
        enabled=EXCLUDED.enabled,
        valid_block_thresh=EXCLUDED.valid_block_thresh,
        logo=EXCLUDED.logo,
        display_name=EXCLUDED.display_name,
        primary_channel=EXCLUDED.primary_channel,
        denoms=EXCLUDED.denoms,
        demeris_addresses=EXCLUDED.demeris_addresses,
        genesis_hash=EXCLUDED.genesis_hash,
        node_info=EXCLUDED.node_info,
        derivation_path=EXCLUDED.derivation_path,
        block_explorer=EXCLUDED.block_explorer
    RETURNING chain_name
`

type AddChainParams struct {
	ChainName        string
	Enabled          bool
	Logo             string
	DisplayName      string
	ValidBlockThresh models.Threshold
	PrimaryChannel   models.DbStringMap
	Denoms           models.DenomList
	DemerisAddresses []string
	GenesisHash      string
	NodeInfo         models.NodeInfo
	DerivationPath   string
	BlockExplorer    string
}

func (q *Queries) AddChain(ctx context.Context, arg AddChainParams) error {
	_, err := q.db.Exec(ctx, addChain,
		arg.ChainName,
		arg.Enabled,
		arg.Logo,
		arg.DisplayName,
		arg.ValidBlockThresh,
		arg.PrimaryChannel,
		arg.Denoms,
		arg.DemerisAddresses,
		arg.GenesisHash,
		arg.NodeInfo,
		arg.DerivationPath,
		arg.BlockExplorer,
	)
	return err
}

const chain = `-- name: Chain :one
SELECT id, enabled, chain_name, valid_block_thresh, logo, display_name, primary_channel, denoms, demeris_addresses, genesis_hash, node_info, derivation_path, block_explorer FROM chains WHERE chain_name=$1 limit 1
`

func (q *Queries) Chain(ctx context.Context, chainName string) (Chain, error) {
	row := q.db.QueryRow(ctx, chain, chainName)
	var i Chain
	err := row.Scan(
		&i.ID,
		&i.Enabled,
		&i.ChainName,
		&i.ValidBlockThresh,
		&i.Logo,
		&i.DisplayName,
		&i.PrimaryChannel,
		&i.Denoms,
		&i.DemerisAddresses,
		&i.GenesisHash,
		&i.NodeInfo,
		&i.DerivationPath,
		&i.BlockExplorer,
	)
	return i, err
}

const chainAmount = `-- name: ChainAmount :one
select count(id) from chains
`

func (q *Queries) ChainAmount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, chainAmount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const chains = `-- name: Chains :many
SELECT id, enabled, chain_name, valid_block_thresh, logo, display_name, primary_channel, denoms, demeris_addresses, genesis_hash, node_info, derivation_path, block_explorer FROM chains
`

func (q *Queries) Chains(ctx context.Context) ([]Chain, error) {
	rows, err := q.db.Query(ctx, chains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chain
	for rows.Next() {
		var i Chain
		if err := rows.Scan(
			&i.ID,
			&i.Enabled,
			&i.ChainName,
			&i.ValidBlockThresh,
			&i.Logo,
			&i.DisplayName,
			&i.PrimaryChannel,
			&i.Denoms,
			&i.DemerisAddresses,
			&i.GenesisHash,
			&i.NodeInfo,
			&i.DerivationPath,
			&i.BlockExplorer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDenoms = `-- name: UpdateDenoms :exec
UPDATE chains
	SET denoms = $1
	WHERE chain_name=$2
`

type UpdateDenomsParams struct {
	Denoms    models.DenomList
	ChainName string
}

func (q *Queries) UpdateDenoms(ctx context.Context, arg UpdateDenomsParams) error {
	_, err := q.db.Exec(ctx, updateDenoms, arg.Denoms, arg.ChainName)
	return err
}
